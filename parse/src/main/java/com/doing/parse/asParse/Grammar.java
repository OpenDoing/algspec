/* Generated By:JJTree&JavaCC: Do not edit this line. Grammar.java */
package com.doing.parse.asParse;

import java.io.InputStream;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Grammar/*@bgen(jjtree)*/implements GrammarTreeConstants, GrammarConstants {/*@bgen(jjtree)*/
  protected JJTGrammarState jjtree = new JJTGrammarState();
        static String specName;                     //文件夹名
        static String subSpecName;                  //文件�?
        static String userName;

        static SpecSysTab specST;
        static SortSysTab sortST;    //存当前sort
        static AttrUnit attrOp;
        static OperUnit operOp;
        static AxiomSet axSet;
        static AxiomUnit axUnit;

        static VarSysTab varST;
        static EquationSysTab globalEST;
        static CondEquation condEST;
        static LetEquation letEST;
        static ConditionSysTab conST;
        static String isGEorLE="GE";

        static SortSysTab tpSortST;

        static String CurrSN;
        static String currOper;

        static String termString;

        static ArrayList<String> paraTypeList;

        static Stack<String> stSort;        //存贮term中类子名�?
        static Stack<String> stOper;        //存贮term中操作名�?
        static boolean isLB=false;          //标志当前表达式是否在中括号中

        static TypeException eTE;
        static String returnMessege;

//<Specification> ::= <Unit> *
//<Unit> ::= <Spec Unit> | <Signature Unit> | <Axiom Unit> | <Definition Unit>
//SpecUnit中不存每�?��规约单元具体内容
  final public void specification(String specID,String subSpecID,String userID) throws ParseException {
                                                                  /*@bgen(jjtree) specification */
  SimpleNode jjtn000 = new SimpleNode(JJTSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACE_TKN);
                System.out.println("160");
                specName=specID;
                subSpecName=subSpecID;
                userName=userID;
                System.out.println("164");
                specST=new SpecSysTab(specID,subSpecID,userID); //带参数构造SpecSysTab
                specST.clear();                          //清除数据库中和specID、subSpecID相关的内�?
                specST.getExistSubSpec();                //读取数据库中specID中其他subSpec的内容，初始化类子名数组和操作名数组

      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPEC_TKN:
        case SIG_TKN:
        case DEF_TKN:
        case AXIOM_TKN:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPEC_TKN:
          SpecUnit();
          break;
        case SIG_TKN:
          SigUnit();
          break;
        case AXIOM_TKN:
          AxiomUnit();
          break;
        case DEF_TKN:
          DefUnit();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RIGHTBRACE_TKN);
    } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              {if (true) throw (RuntimeException)jjte000;}
            }
            if (jjte000 instanceof ParseException) {
              {if (true) throw (ParseException)jjte000;}
            }
            {if (true) throw (Error)jjte000;}
    } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
    }
  }

//<Spec unit> ::= 
//  Spec<Sort Name> [<Observability>];
//  [extends <Sort Names>] [uses <Sort Names>]
//  <Signature>; [<Axioms>] 
//  End
//每解析一个sort单元就将解析结果存入数据库，并将sortName和operName存到specUnit
  final public void SpecUnit() throws ParseException {
                 /*@bgen(jjtree) SpecUnit */
                 SimpleNode jjtn000 = new SimpleNode(JJTSPECUNIT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(SPEC_TKN);
      t = Identifier();
                System.out.println("begin to parse Spec Unit:" +t.image);
                if(!specST.addUniqSN(t.image))   //判断sortID唯一性，若重复报错，否则将其名字存入specUnit中sortName数组
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been defined as an operation or a sort name.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}

                }
                CurrSN=t.image;
                sortST=new SortSysTab();                //新建�?��sortST单元
                sortST.setSortName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBSERVABLE_TKN:
      case UNOBSERVABLE_TKN:
        Observability();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS_TKN:
        ExtendsSorts();
        jj_consume_token(SEMICOLON_TKN);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USES_TKN:
        UsesSorts();
        jj_consume_token(SEMICOLON_TKN);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      Signature();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AXIOM_TKN:
        Axioms();
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(END_TKN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                sortST.writeSortToDB(specName,subSpecName,userName);  //将该sort存入数据�?
//		System.out.println("Successfully parse the Spec Unit: " + CurrSN);

    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void SigUnit() throws ParseException {
                /*@bgen(jjtree) SigUnit */
                SimpleNode jjtn000 = new SimpleNode(JJTSIGUNIT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(SIG_TKN);
      t = Identifier();
                System.out.println("begin to parse Sig Unit:" +t.image);
                if(!specST.addUniqSN(t.image))
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been defined as an operation or a sort name.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}

                }
                CurrSN=t.image;
                sortST=new SortSysTab();
                sortST.setSortName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBSERVABLE_TKN:
      case UNOBSERVABLE_TKN:
        Observability();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS_TKN:
        ExtendsSorts();
        jj_consume_token(SEMICOLON_TKN);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USES_TKN:
        UsesSorts();
        jj_consume_token(SEMICOLON_TKN);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      Signature();
      jj_consume_token(END_TKN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                sortST.writeSortToDB(specName,subSpecName,userName);
                System.out.println("Successfully parse the Signature Unit: " + CurrSN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Axiom Unit> ::=
//  Axiom <Sort Name>;
//    <Axiom List>
//  End
  final public void AxiomUnit() throws ParseException {
                  /*@bgen(jjtree) AxiomUnit */
                  SimpleNode jjtn000 = new SimpleNode(JJTAXIOMUNIT);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(AXIOM_TKN);
      t = Identifier();
                System.out.println("Begin to parse Axiom Unit: "+ t.image);
                if(specST.isUniqSortName(t.image))              //判定是否定义过该类子�?若未定义则报�?
                {
                        eTE = new TypeException(TypeError.SORT_NOT_DEFINED, "Its signature part has not been defined.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
                else
                {
                        sortST=new SortSysTab();                    //新建�?��sortST用于当前公理对应的类子信�?
                        sortST.setSortName(t.image);
                        sortST.readSigFromDB(specName,subSpecName,userName);  //从数据库中读取当前类子的基调
                }
      jj_consume_token(SEMICOLON_TKN);
      AxiomList();
      jj_consume_token(END_TKN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                axSet.writeAxiomToDB(specName,subSpecName,sortST.getSortName(),userName);  //将公理写入数据库
                System.out.println("Successfully parse the Axiom Unit: " + CurrSN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Definition unit> ::= 
//  Definition [uses <Sort Names>]
//  <Signature>; [<Axioms>] 
//  End
//类子名为Definiton，其他与sort单元相同，该部分语义�?
  final public void DefUnit() throws ParseException {
                /*@bgen(jjtree) DefUnit */
  SimpleNode jjtn000 = new SimpleNode(JJTDEFUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DEF_TKN);
                System.out.println("Begin to parse Defintion Unit!");
                //处理def单元
                sortST=new SortSysTab();
                sortST.setSortName("Definition");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USES_TKN:
        UsesSorts();
        jj_consume_token(SEMICOLON_TKN);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      Signature();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AXIOM_TKN:
        Axioms();
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      jj_consume_token(END_TKN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                sortST.writeSortToDB(specName,subSpecName,userName);
                System.out.println("Successfully parse the Defintion Unit! ");
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Observability> ::= is unobservable | is observable by <Op Id>
//�?
  final public void Observability() throws ParseException {
                      /*@bgen(jjtree) Observability */
                      SimpleNode jjtn000 = new SimpleNode(JJTOBSERVABILITY);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBSERVABLE_TKN:
        jj_consume_token(OBSERVABLE_TKN);
        t = Identifier();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                sortST.setObOpName(t.image);
        break;
      case UNOBSERVABLE_TKN:
        jj_consume_token(UNOBSERVABLE_TKN);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ExtendsSorts() throws ParseException {
                     /*@bgen(jjtree) ExtendsSorts */
  SimpleNode jjtn000 = new SimpleNode(JJTEXTENDSSORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(EXTENDS_TKN);
      ExtendsSortList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ExtendsSortList() throws ParseException {
                        /*@bgen(jjtree) ExtendsSortList */
                        SimpleNode jjtn000 = new SimpleNode(JJTEXTENDSSORTLIST);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = Identifier();
                //除了判断是否已经声明过是否需要其他判断？（比如是否已经定义过？或者最后判断）
                if(!sortST.addUniqExSortToList(t.image))
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been acted as super one in the sort.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        ExtendsSortList();
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void UsesSorts() throws ParseException {
                  /*@bgen(jjtree) UsesSorts */
  SimpleNode jjtn000 = new SimpleNode(JJTUSESSORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(USES_TKN);
      UsesSortList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void UsesSortList() throws ParseException {
                     /*@bgen(jjtree) UsesSortList */
                     SimpleNode jjtn000 = new SimpleNode(JJTUSESSORTLIST);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        t = Identifier();
        break;
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
        t = BasicType();
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                //除了判断是否已经声明过是否需要其他判断？
                if(!sortST.addUniqUsSortToList(t.image))
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been imported in the sort.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        System.out.println(sortST.getSortName());
                        {if (true) throw eTE;}

                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        UsesSortList();
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Signature> ::= {[<Constant>]|[<Attribute>]|[<Operator>]}*
  final public void Signature() throws ParseException {
                  /*@bgen(jjtree) Signature */
  SimpleNode jjtn000 = new SimpleNode(JJTSIGNATURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST_TKN:
        case VAR_TKN:
        case OPERATORS_TKN:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST_TKN:
          Constant();
          break;
        case VAR_TKN:
          Attribute();
          break;
        case OPERATORS_TKN:
          Operation();
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Constant() throws ParseException {
                 /*@bgen(jjtree) Constant */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(CONST_TKN);
      jj_consume_token(SELECTOR_TKN);
      ConstList();
      jj_consume_token(SEMICOLON_TKN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ConstList() throws ParseException {
                  /*@bgen(jjtree) ConstList */
                  SimpleNode jjtn000 = new SimpleNode(JJTCONSTLIST);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = Identifier();
                if(specST.isUniqSortName(t.image))   //判断是否和已经定义的sort名重�?
                {
                        if(sortST.checkOpName(t.image))   //判断是否和当前类子中的其他oper名重�?
                        {
                                sortST.addConstOpName(t.image);
                                specST.addOperName(t.image);
                        }
                        else
                        {
                                eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The ConstName has been used as operator name.", t);
                                main.messegeString=eTE.returnMessage();
                                System.out.println(eTE.prettyMessage());
                                {if (true) throw eTE;}
                        }
                }
                else
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The ConstName has been used as sort name.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        ConstList();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Attribute> ::= Attr <AttrList>;
  final public void Attribute() throws ParseException {
                  /*@bgen(jjtree) Attribute */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(VAR_TKN);
      AttrList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<AttrList> ::= <AttributeType> [; <AttrList>]
  final public void AttrList() throws ParseException {
                 /*@bgen(jjtree) AttrList */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_3:
      while (true) {
        AttributeType();
        jj_consume_token(SEMICOLON_TKN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_3;
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<AttributeType> ::= <Attr IDs> : <Sort Name>  
// {对每个AttrID新建�?��AttrUnit，初始化ID,Type后（�?��断合法�?）加入当前类子attrOpList数组}
  final public void AttributeType() throws ParseException {
                      /*@bgen(jjtree) AttributeType */
                      SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTETYPE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);Token t;
    try {
      AttrOpIDs();
      jj_consume_token(SELECTOR_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
        t = BasicType();
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                          sortST.setAttrOpType(t.image);
        break;
      case IDENTIFIER:
        t = Identifier();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(sortST.checkOpType(t.image))        //�?��类型合法性（为void或已经申明过的类子）
                {
                        sortST.setAttrOpType(t.image);         //设置OpId的类�?
                }
                else
                {
                        eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The Attribute Type Sort has not been declared.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Attr IDs> ::= <Attr ID> [, <Attr IDs>]
//<Attr ID> ::= <Identifier> [ <Index> ]
  final public void AttrOpIDs() throws ParseException {
                  /*@bgen(jjtree) AttrOpIDs */
                  SimpleNode jjtn000 = new SimpleNode(JJTATTROPIDS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;String index = "";
    try {
      t = Identifier();
                attrOp=new AttrUnit();                 //新建�?��AttrUnit对象
                if(specST.isUniqSortName(t.image))     //判断是否和已有类子名冲突
                {
                        if(sortST.checkOpName(t.image))    //�?��是否和当前类子中的其他操作名冲突，不冲突则将其add到当前sort的操作op数组
                        {
                                specST.addOperName(t.image);   //类子名合法则将将其add到specST的oper数组
                                attrOp.setAttrName(t.image);   //设置当前attrOp的name
                        }
                        else
                        {
                                eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The AttrOpName has been used as operator name.", t);
                                main.messegeString=eTE.returnMessage();
                                System.out.println(eTE.prettyMessage());
                                {if (true) throw eTE;}
                        }
                }
                else
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The AttrOpName has been used as sort name.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTBRACKET_TKN:
        index = Index();
                       attrOp.setIndexString(index);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
         sortST.addAttrOpUnit(attrOp);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        AttrOpIDs();
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Index> ::= "[" <Index set> "]" 
  final public String Index() throws ParseException {
                /*@bgen(jjtree) Index */
                SimpleNode jjtn000 = new SimpleNode(JJTINDEX);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);String index = "";
    try {
      jj_consume_token(LEFTBRACKET_TKN);
      index = IndexSet();
      jj_consume_token(RIGHTBRACKET_TKN);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return index;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<Index set> ::= (<Single Index>[,<Index set>]|*)
  final public String IndexSet() throws ParseException {
                   /*@bgen(jjtree) IndexSet */
                   SimpleNode jjtn000 = new SimpleNode(JJTINDEXSET);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t; String sIndex = ""; String index = "";
    try {
      sIndex = SingleIndex();
                             index=index+sIndex;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        t = jj_consume_token(COMMA_TKN);
                       index=index+t.image;
        sIndex = IndexSet();
                                                              index=index+sIndex;
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return index;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<Single Index> ::= <Enumerated ID> | <Lower bound> ".." <Upper bound>
//<Lower bound> ::= <Natural number>
//<Upper bound> ::= <Natural number> | "*" 
  final public String SingleIndex() throws ParseException {
                      /*@bgen(jjtree) SingleIndex */
                      SimpleNode jjtn000 = new SimpleNode(JJTSINGLEINDEX);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);Token t; String sToken = "";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POSITIVEINT_TKN:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case POSITIVEINT_TKN:
          t = jj_consume_token(POSITIVEINT_TKN);
                                  sToken += t.image;
          t = jj_consume_token(BETWEEN_TKN);
                             sToken += t.image;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case POSITIVEINT_TKN:
            t = jj_consume_token(POSITIVEINT_TKN);
                                sToken += t.image;
            break;
          case TIMES_TKN:
            t = jj_consume_token(TIMES_TKN);
            break;
          default:
            jj_la1[23] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                                                                        sToken += t.image;
          break;
        case IDENTIFIER:
          t = Identifier();
                            sToken += t.image;
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case TIMES_TKN:
        t = jj_consume_token(TIMES_TKN);
                          sToken += t.image;
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return sToken;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<Operator> ::= Operation <OpList>;
  final public void Operation() throws ParseException {
                  /*@bgen(jjtree) Operation */
  SimpleNode jjtn000 = new SimpleNode(JJTOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OPERATORS_TKN);
      OpList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<OpList> ::= <Operation> [; <OpList>]
  final public void OpList() throws ParseException {
               /*@bgen(jjtree) OpList */
  SimpleNode jjtn000 = new SimpleNode(JJTOPLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_4:
      while (true) {
        Oper();
        jj_consume_token(SEMICOLON_TKN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_4;
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Operation> ::= <Operator ID> "(" <Domain Type> ")" ":" <Co-domain Type>
  final public void Oper() throws ParseException {
             /*@bgen(jjtree) Oper */
             SimpleNode jjtn000 = new SimpleNode(JJTOPER);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = Identifier();
                operOp=new OperUnit();         //新建�?��OperUnit对象
                if(specST.isUniqSortName(t.image))     //判断是否和已有类子名冲突
                {
                        if(sortST.checkOpName(t.image))    //�?��是否和当前类子中的其他操作名冲突，不冲突的话将其add到当前sort的操作op数组
                        {
                                specST.addOperName(t.image);   //类子名合法则将将其add到specST的oper数组
                                operOp.setOperName(t.image);   //设置当前operOp的name
                        }
                        else
                        {
                                eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The GenOpName has been used as operator name.", t);
                                main.messegeString=eTE.returnMessage();
                                System.out.println(eTE.prettyMessage());
                                {if (true) throw eTE;}
                        }
                }
                else
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The GenOpName has been used as sort name.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
                //判断是否为obOp

      jj_consume_token(LEFTPAREN_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID_TKN:
        t = jj_consume_token(VOID_TKN);
                                        operOp.addDomainType(t.image);
        break;
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
      case IDENTIFIER:
        DomainType();
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RIGHTPAREN_TKN);
      jj_consume_token(SELECTOR_TKN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID_TKN:
        t = jj_consume_token(VOID_TKN);
                                       operOp.addCoDomainType(t.image);
        break;
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
      case IDENTIFIER:
        CodomainType();
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         sortST.addOperOp(operOp);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Domain Type> ::= <Type> | void
  final public void DomainType() throws ParseException {
                   /*@bgen(jjtree) DomainType */
                   SimpleNode jjtn000 = new SimpleNode(JJTDOMAINTYPE);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
        t = BasicType();
                operOp.addDomainType(t.image);
        break;
      case IDENTIFIER:
        t = Identifier();
                if(sortST.checkOpType(t.image))        //�?��类型合法性（为当前类子或已经申明过的类子�?
                {
//			if(!operOp.addDomainType(t.image))  //�?��唯一性后将该类型add到域数组
//			{
//				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Type has been acted as super one in domain.", t);
//				System.out.println(eTE.prettyMessage());
//				throw eTE;
//			}     
            operOp.addDomainType(t.image);
                }
                else
                {
                        eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The DomainType has not been declared.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        DomainType();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Co-domain Type> ::= <Type> | void
  final public void CodomainType() throws ParseException {
                     /*@bgen(jjtree) CodomainType */
                     SimpleNode jjtn000 = new SimpleNode(JJTCODOMAINTYPE);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
        t = BasicType();
                           operOp.addCoDomainType(t.image);
        break;
      case IDENTIFIER:
        t = Identifier();
                if(sortST.checkOpType(t.image))         //�?��类型合法性（为当前类子或已经申明过的类子�?
                {
//			if(!operOp.addCoDomainType(t.image))//�?��唯一性后将该类型add到域数组
//			{
//				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Type has been acted as super one in codomain.", t);
//				System.out.println(eTE.prettyMessage());
//				throw eTE;
//			}   
        operOp.addCoDomainType(t.image);

                }
                else
                {
                        eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The CoDomainType has not been declared.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        CodomainType();
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Axioms> ::= Axiom: <Axiom List>
  final public void Axioms() throws ParseException {
               /*@bgen(jjtree) Axioms */
  SimpleNode jjtn000 = new SimpleNode(JJTAXIOMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(AXIOM_TKN);
      AxiomList();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//<Axiom List> ::= <Axiom> [<Axiom List>]
  final public void AxiomList() throws ParseException {
                  /*@bgen(jjtree) AxiomList */
  SimpleNode jjtn000 = new SimpleNode(JJTAXIOMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
                axSet=new AxiomSet();
      label_5:
      while (true) {
        Axiom();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case POSITIVEINT_TKN:
        case REAL_TKN:
        case FORALL_TKN:
        case LET_TKN:
        case LEFTBRACKET_TKN:
        case LEFTPAREN_TKN:
        case NULL_TKN:
        case TRUE_TKN:
        case FALSE_TKN:
        case BOOLEAN_TKN:
        case INTEGER_TKN:
        case LONG_TKN:
        case STRING_TKN:
        case DATETIME_TKN:
        case DOUBLE_TKN:
        case FLOAT_TKN:
        case NOT_TKN:
        case IDENTIFIER:
        case CSTRING_TKN:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_5;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         sortST.addAxUnit(axSet);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Axiom> ::= <Var Declarations> <Equations> End|<Equations> 
  final public void Axiom() throws ParseException {
              /*@bgen(jjtree) Axiom */
  SimpleNode jjtn000 = new SimpleNode(JJTAXIOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
         axUnit=new AxiomUnit();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FORALL_TKN:
        VarDeclarations();
        Equations();
                axSet.addAxiomUnit(axUnit);
        jj_consume_token(END_TKN);
        break;
      case POSITIVEINT_TKN:
      case REAL_TKN:
      case LET_TKN:
      case LEFTBRACKET_TKN:
      case LEFTPAREN_TKN:
      case NULL_TKN:
      case TRUE_TKN:
      case FALSE_TKN:
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
      case NOT_TKN:
      case IDENTIFIER:
      case CSTRING_TKN:
        Equations();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                axSet.addAxiomUnit(axUnit);
                System.out.println("595");
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Var Declarations> ::= For all <Var-Sort Pairs> that  全局变量
  final public void VarDeclarations() throws ParseException {
                        /*@bgen(jjtree) VarDeclarations */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(FORALL_TKN);
      VarSortPairs();
      jj_consume_token(THAT_TKN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Var-Sort Pairs> ::= <Var IDs> : <Sort Name> [, <Var-Sort Pairs>]
  final public void VarSortPairs() throws ParseException {
                     /*@bgen(jjtree) VarSortPairs */
  SimpleNode jjtn000 = new SimpleNode(JJTVARSORTPAIRS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      VarIDs();
      jj_consume_token(SELECTOR_TKN);
      Type();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        VarSortPairs();
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Var IDs> ::= <Var ID> [, <Var IDs>]
  final public void VarIDs() throws ParseException {
               /*@bgen(jjtree) VarIDs */
               SimpleNode jjtn000 = new SimpleNode(JJTVARIDS);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = Identifier();
                varST=new VarSysTab();
                if(specST.isUniqSortName(t.image)&&specST.isUniqOperName(t.image))     //判断是否和已有类子名或操作名冲突{基本数据类型名？}
                {
                        if(axUnit.addGlobVarName(t.image))    //�?��是否和已经定义过的全�?��量名冲突
                        {
                                {varST.setVarName(t.image);}
                        }
                        else
                        {
                                eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been used as globalvarname.", t);
                                main.messegeString=eTE.returnMessage();
                                System.out.println(eTE.prettyMessage());
                                {if (true) throw eTE;}
                        }
                }
                else
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been used as sort name or an operator name.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
                axUnit.addGlobVarST(varST);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        VarIDs();
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Type> ::= <Sort Name>
  final public void Type() throws ParseException {
             /*@bgen(jjtree) Type */
             SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
        t = BasicType();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         axUnit.setVarType(t.image);
        break;
      case IDENTIFIER:
        t = Identifier();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(sortST.checkOpType(t.image))        //�?��类型合法性（为void或已经申明过的类子）
                {
                        {axUnit.setVarType(t.image);       //设置OpId的类�?
            }
                }
                else
                {
                        eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The Var Type Sort has not been declared.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Equations> ::= <Equation> [<Equations>]
  final public void Equations() throws ParseException {
                  /*@bgen(jjtree) Equations */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_6:
      while (true) {
        Equation();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case POSITIVEINT_TKN:
        case REAL_TKN:
        case LET_TKN:
        case LEFTBRACKET_TKN:
        case LEFTPAREN_TKN:
        case NULL_TKN:
        case TRUE_TKN:
        case FALSE_TKN:
        case BOOLEAN_TKN:
        case INTEGER_TKN:
        case LONG_TKN:
        case STRING_TKN:
        case DATETIME_TKN:
        case DOUBLE_TKN:
        case FLOAT_TKN:
        case NOT_TKN:
        case IDENTIFIER:
        case CSTRING_TKN:
          ;
          break;
        default:
          jj_la1[38] = jj_gen;
          break label_6;
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Equation> ::=<Cond-Equation>|<Let-Equation>
  final public void Equation() throws ParseException {
                 /*@bgen(jjtree) Equation */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
         globalEST=new EquationSysTab();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POSITIVEINT_TKN:
      case REAL_TKN:
      case LEFTBRACKET_TKN:
      case LEFTPAREN_TKN:
      case NULL_TKN:
      case TRUE_TKN:
      case FALSE_TKN:
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
      case NOT_TKN:
      case IDENTIFIER:
      case CSTRING_TKN:
        CondEquation();
                        globalEST.addConEqua(condEST);
        break;
      case LET_TKN:
        LetEquation();
                       globalEST.addLetEqua(letEST);
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         axUnit.addGlobE(globalEST);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Cond-Equation> ::=<Condition>[<If-Conditions>];
  final public void CondEquation() throws ParseException {
                     /*@bgen(jjtree) CondEquation */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDEQUATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
         condEST=new CondEquation();
      Condition();
                     condEST.setCond(conST);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        jj_consume_token(IF_TKN);
        Conditions();
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON_TKN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Let-Equation> ::=Let <Var Definitions> in <Cond-Equations> End
  final public void LetEquation() throws ParseException {
                     /*@bgen(jjtree) LetEquation */
  SimpleNode jjtn000 = new SimpleNode(JJTLETEQUATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
         letEST=new LetEquation();
      jj_consume_token(LET_TKN);
                   isGEorLE="LE";
      VarDefinitions();
      jj_consume_token(IN_TKN);
      CondEquations();
                                                                             isGEorLE="GE";letEST.addConEqua(condEST);
      jj_consume_token(END_TKN);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Cond-Equations> ::=<Cond-Equation> [<Cond-Equations>]
  final public void CondEquations() throws ParseException {
                      /*@bgen(jjtree) CondEquations */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDEQUATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_7:
      while (true) {
        CondEquation();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case POSITIVEINT_TKN:
        case REAL_TKN:
        case LEFTBRACKET_TKN:
        case LEFTPAREN_TKN:
        case NULL_TKN:
        case TRUE_TKN:
        case FALSE_TKN:
        case BOOLEAN_TKN:
        case INTEGER_TKN:
        case LONG_TKN:
        case STRING_TKN:
        case DATETIME_TKN:
        case DOUBLE_TKN:
        case FLOAT_TKN:
        case NOT_TKN:
        case IDENTIFIER:
        case CSTRING_TKN:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_7;
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Condition> ::= <Term> <Relation OP> <Term> | ~<Condition>
  final public void Condition() throws ParseException {
                  /*@bgen(jjtree) Condition */
                  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t; String returnType = "";String termName="";
    try {
         conST=new ConditionSysTab();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POSITIVEINT_TKN:
      case REAL_TKN:
      case LEFTBRACKET_TKN:
      case LEFTPAREN_TKN:
      case NULL_TKN:
      case TRUE_TKN:
      case FALSE_TKN:
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
      case IDENTIFIER:
      case CSTRING_TKN:
        returnType = Term();
                            conST.setLeftType(returnType);conST.setLeftTerm(termString);
        t = RelationOP();
                         conST.setReOp(t.image);
        returnType = Term();
                           conST.setRightType(returnType);conST.setRightTerm(termString);
        break;
      case NOT_TKN:
        t = jj_consume_token(NOT_TKN);
                        conST.setConnector(t.image);
        Condition();
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(!conST.checkType())            //类型�?��
                {
                        eTE = new TypeException(TypeError.TERMSTYPE_NOT_AGREE,"LeftTermType of "+conST.getLeftTerm()+" does not agree with RightTermType of "+conST.getRightTerm(), t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public Token RelationOP() throws ParseException {
 /*@bgen(jjtree) RelationOP */
 SimpleNode jjtn000 = new SimpleNode(JJTRELATIONOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN_TKN:
        t = jj_consume_token(ASSIGN_TKN);
        break;
      case NOTEQUAL_TKN:
        t = jj_consume_token(NOTEQUAL_TKN);
        break;
      case MORETHAN_TKN:
        t = jj_consume_token(MORETHAN_TKN);
        break;
      case LESSTHAN_TKN:
        t = jj_consume_token(LESSTHAN_TKN);
        break;
      case MORETHANEQU_TKN:
        t = jj_consume_token(MORETHANEQU_TKN);
        break;
      case LESSTHANEQU_TKN:
        t = jj_consume_token(LESSTHANEQU_TKN);
        break;
      case OBJECTEQUAL_TKN:
        t = jj_consume_token(OBJECTEQUAL_TKN);
        break;
      case EQUAL_TKN:
        t = jj_consume_token(EQUAL_TKN);
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

//<If-Conditions>::= [, if <Conditions>]
//<Conditions> ::= <UnionCondition> ["," <UnionCondition>]
//<UnionCondition>::=<Condition> ("or"<Condition>)*
  final public void Conditions() throws ParseException {
                   /*@bgen(jjtree) Conditions */
                   SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONS);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t;
    try {
      Condition();
         condEST.addIfCond(conST);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        t = jj_consume_token(COMMA_TKN);
        Conditions();
         conST.setConnector(t.image);
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Var Definitions> ::=<Var Assignment> [, <Var Definitions>]
  final public void VarDefinitions() throws ParseException {
                       /*@bgen(jjtree) VarDefinitions */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      VarAssignment();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA_TKN:
        jj_consume_token(COMMA_TKN);
        VarDefinitions();
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Var Assignment> ::= <Var ID> = <Term>
  final public void VarAssignment() throws ParseException {
                      /*@bgen(jjtree) VarAssignment */
                      SimpleNode jjtn000 = new SimpleNode(JJTVARASSIGNMENT);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);Token t; String returnType = "";
    try {
      //�?��变量
              t = Identifier();
                if(specST.isUniqSortName(t.image)&&specST.isUniqOperName(t.image))     //判断是否和已有类子名或操作名冲突{基本数据类型名？}
                {
                        if(axUnit.checkLocalVarName(t.image)&&letEST.addLocalV(t.image))    //�?��是否和已经定义过的全�?��量名冲突
                        {
                                varST=new VarSysTab();
                                varST.setVarName(t.image);
                        }
                        else

                        {
                                eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been defined.", t);
                                main.messegeString=eTE.returnMessage();
                                System.out.println(eTE.prettyMessage());
                                {if (true) throw eTE;}
                        }
                }
                else
                {
                        eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been used as sort name or an operator name.", t);
                        main.messegeString=eTE.returnMessage();
                        System.out.println(eTE.prettyMessage());
                        {if (true) throw eTE;}
                }
      jj_consume_token(ASSIGN_TKN);
      returnType = Term();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                varST.setVarTerm(termString);
                varST.setVarType(returnType);
                letEST.addLocalVar(varST);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Term>::=<AddExpression>
  final public String Term() throws ParseException {
               /*@bgen(jjtree) Term */
               SimpleNode jjtn000 = new SimpleNode(JJTTERM);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);String returntype;
    try {
                termString="";
                stSort=new Stack<String>();
                stOper=new Stack<String>();
      returntype = AddExpression();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         System.out.println("returntype:"+returntype);System.out.println("term:"+termString);{if (true) return returntype;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<AddExpression>::=<MulticativeExpression>("+"|"-"|"*"|"/")<MulticativeExpression>*
  final public String AddExpression() throws ParseException {
                        /*@bgen(jjtree) AddExpression */
                        SimpleNode jjtn000 = new SimpleNode(JJTADDEXPRESSION);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);Token t;String returntype;
    try {
      returntype = MulticativeExpression();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ADD_TKN:
        case MINUS_TKN:
        case TIMES_TKN:
        case DIVIDE_TKN:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_8;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ADD_TKN:
          t = jj_consume_token(ADD_TKN);
          break;
        case MINUS_TKN:
          t = jj_consume_token(MINUS_TKN);
          break;
        case TIMES_TKN:
          t = jj_consume_token(TIMES_TKN);
          break;
        case DIVIDE_TKN:
          t = jj_consume_token(DIVIDE_TKN);
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         termString+=t.image;
        MulticativeExpression();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                {if (true) return returntype;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<MulticativeExpression>::=
//<UnaryExpression>("."|"#")<UnaryExpression>*
  final public String MulticativeExpression() throws ParseException {
                                /*@bgen(jjtree) MulticativeExpression */
                                SimpleNode jjtn000 = new SimpleNode(JJTMULTICATIVEEXPRESSION);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);Token t;String type;String nType="";
    try {
      type = UnaryExpression();
                if(type.equals("unknownOp!"))
                {
                        type=sortST.checkOperType(currOper,specName,userName);
                        if(type.equals("ConstOp"))stOper.pop();
                }
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT_TKN:
        case SHARP_TKN:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT_TKN:
          t = jj_consume_token(DOT_TKN);
                if(type.equals("error!"))
                {
                        System.out.println("varType is wrong!");
                }
          break;
        case SHARP_TKN:
          t = jj_consume_token(SHARP_TKN);
          break;
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
         termString+=t.image;
        nType = UnaryExpression();
                if((sortST.isSort(type)))                 //type类型为当前类�?
                {
                        type="unknownOp!";                     //设置type类型为unknownOp!
                        if(nType.equals("unknownOp!"))        //nType为unknownOp!
                        {
                                type=sortST.checkOperType(currOper,specName,userName); //判断type类型   【判断参数类型�?
                                stOper.pop();
                                if(isLB)
                                        type=stSort.pop();
                                else
                                    stSort.pop();
                                stSort.push(type);
                        }
                }
                else if(!specST.isUniqSortName(type))       //type类型为非当前类子  【判断参数类型�?
                {
                        tpSortST=new SortSysTab();
                        tpSortST.setSortName(type);
                        tpSortST.readSigFromDB(specName,userName);
                        type="unknownOp!";

                        if(nType.equals("unknownOp!"))
                        {
                                type=tpSortST.checkOperType(currOper,specName,userName);
                                stOper.pop();
                                if(isLB)
                                        type=stSort.pop();
                                else
                                    stSort.pop();
                                stSort.push(type);
                        }
            }
            else {System.out.println("leftDotType error!");}
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        {if (true) return type;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<UnaryExpression>::="("<Term>")"
//|Identifier["("<Parameters>")"]
//|Identifier["[""]"]
//|<CString>
//|<NULL>
//|<Bool>
//|<POSITIVEINT_TKN>
  final public String UnaryExpression() throws ParseException {
                          /*@bgen(jjtree) UnaryExpression */
                          SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);Token t;String type="";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFTPAREN_TKN:
        t = jj_consume_token(LEFTPAREN_TKN);
                termString+=t.image;
        type = AddExpression();
        t = jj_consume_token(RIGHTPAREN_TKN);
                                                   termString+=t.image;
        break;
      case LEFTBRACKET_TKN:
        t = jj_consume_token(LEFTBRACKET_TKN);
                isLB=true;
                termString+=t.image;
        type = AddExpression();
        t = jj_consume_token(RIGHTBRACKET_TKN);
                //type=stSort.pop();
                termString+=t.image;
                isLB=false;
        break;
      case BOOLEAN_TKN:
      case INTEGER_TKN:
      case LONG_TKN:
      case STRING_TKN:
      case DATETIME_TKN:
      case DOUBLE_TKN:
      case FLOAT_TKN:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN_TKN:
        case INTEGER_TKN:
        case LONG_TKN:
        case STRING_TKN:
        case DATETIME_TKN:
        case DOUBLE_TKN:
        case FLOAT_TKN:
          t = BasicType();
          break;
        case IDENTIFIER:
          t = Identifier();
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                        termString+=t.image;
                //判断类型（类子名、操作名、变量名�?
                if(axUnit.isGlobalVar(t.image))   //全局变量
                {
                        type=axUnit.getGlobalVarType(t.image);
                    stSort.push(type);
            }
                else if(sortST.isSort(t.image))   //当前类子�?
                {
                        type=t.image;
                        stSort.push(type);
                }
                else if(isGEorLE.equals("LE"))    //�?��等式中的�?��变量
                {
                        if(letEST.isLocalVar(t.image))
                        {
                            type=letEST.getLocalVarType(t.image);
                            stSort.push(type);
                        }
                        else                       //为未知合法操作名或非�?
                    {
                        type="unknownOp!";
                        System.out.println("jjt952"+t.image);
                        if(sortST.checkOperType(t.image,specName,userName).equals("ConstOp"))
                    {
                        type=sortST.getSortName();
                        stSort.push(t.image);
                    }
                    else
                    {
                        currOper=t.image;
                        stOper.push(t.image);
                    }
                    }
                }
                else   //为未知合法操作名或非�?
            {
                type="unknownOp!";
                if(sortST.checkOperType(t.image,specName,userName).equals("ConstOp"))
                {
                        type=sortST.getSortName();
                        stSort.push(t.image);
                }
                else
                {
                        currOper=t.image;
                        stOper.push(t.image);
                }

            }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFTBRACKET_TKN:
        case LEFTPAREN_TKN:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LEFTPAREN_TKN:
            t = jj_consume_token(LEFTPAREN_TKN);
                termString+=t.image;
                paraTypeList=new ArrayList<String>();
            Parameter();
            //初始化参数类型数�?
                      t = jj_consume_token(RIGHTPAREN_TKN);
                type="unknownOp!";
                //currSort=stSort.peek();
                currOper=stOper.peek();
                //operOp=new operName();
                //operOp.setOperName(operOp);

                termString+=t.image;
            break;
          case LEFTBRACKET_TKN:
            t = jj_consume_token(LEFTBRACKET_TKN);
           termString+=t.image;
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case POSITIVEINT_TKN:
            case IDENTIFIER:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case IDENTIFIER:
                t = Identifier();
                break;
              case POSITIVEINT_TKN:
                t = jj_consume_token(POSITIVEINT_TKN);
                break;
              default:
                jj_la1[51] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            default:
              jj_la1[52] = jj_gen;
              ;
            }
            t = jj_consume_token(RIGHTBRACKET_TKN);
           termString+=t.image;System.out.println("967"+termString);
            break;
          default:
            jj_la1[53] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
        }
        break;
      case CSTRING_TKN:
        t = jj_consume_token(CSTRING_TKN);
                           termString+=t.image;type="String";
        break;
      case POSITIVEINT_TKN:
        t = jj_consume_token(POSITIVEINT_TKN);
                               termString+=t.image;type="Integer";
        break;
      case REAL_TKN:
        t = jj_consume_token(REAL_TKN);
                    termString+=t.image;type="Real";
        break;
      case NULL_TKN:
        t = jj_consume_token(NULL_TKN);
                        termString+=t.image;type="Null";
        break;
      case TRUE_TKN:
      case FALSE_TKN:
        BoolTerm();
                    type="Bool";
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         {if (true) return type;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<Parameters>::=<AddExpression>
  final public void Parameter() throws ParseException {
                  /*@bgen(jjtree) Parameter */
                  SimpleNode jjtn000 = new SimpleNode(JJTPARAMETER);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;String paraType;
    try {
      paraType = MulticativeExpression();
                stSort.pop();
                paraTypeList.add(paraType);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA_TKN:
          ;
          break;
        default:
          jj_la1[56] = jj_gen;
          break label_10;
        }
        t = jj_consume_token(COMMA_TKN);
         termString+=t.image;
        paraType = MulticativeExpression();
         paraTypeList.add(paraType);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         for(int i=0;i<paraTypeList.size();i++)
        System.out.println("942"+paraTypeList.get(i));
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<Bool Term> ::= True | False 
  final public void BoolTerm() throws ParseException {
                 /*@bgen(jjtree) BoolTerm */
                 SimpleNode jjtn000 = new SimpleNode(JJTBOOLTERM);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE_TKN:
        t = jj_consume_token(TRUE_TKN);
        break;
      case FALSE_TKN:
        t = jj_consume_token(FALSE_TKN);
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         termString+=t.image;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public Token Identifier() throws ParseException {
                    /*@bgen(jjtree) Identifier */
                    SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return t;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token BasicType() throws ParseException {
                    /*@bgen(jjtree) BasicType */
                    SimpleNode jjtn000 = new SimpleNode(JJTBASICTYPE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN_TKN:
        t = jj_consume_token(BOOLEAN_TKN);
        break;
      case INTEGER_TKN:
        t = jj_consume_token(INTEGER_TKN);
        break;
      case LONG_TKN:
        t = jj_consume_token(LONG_TKN);
        break;
      case STRING_TKN:
        t = jj_consume_token(STRING_TKN);
        break;
      case DATETIME_TKN:
        t = jj_consume_token(DATETIME_TKN);
        break;
      case DOUBLE_TKN:
        t = jj_consume_token(DOUBLE_TKN);
        break;
      case FLOAT_TKN:
        t = jj_consume_token(FLOAT_TKN);
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return t;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public GrammarTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[59];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1e00,0x1e00,0x6000,0x8000,0x10000,0x1000,0x6000,0x8000,0x10000,0x10000,0x1000,0x6000,0x40000000,0x0,0x40000000,0xe0000,0xe0000,0x40000000,0x0,0x0,0x0,0x40000000,0x40000000,0x80,0x80,0x80,0x0,0x200000,0x200000,0x0,0x40000000,0x0,0x40000000,0x2400180,0x2400180,0x40000000,0x40000000,0x0,0x2000180,0x2000180,0x40000000,0x180,0x180,0x0,0x40000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x0,0x0,0x180,0x40000000,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f00,0x0,0x0,0x0,0x0,0x0,0x7f00,0x1,0x0,0x0,0x40000000,0x0,0x40000000,0x0,0x7f00,0x7f00,0x7f00,0x0,0x7f00,0x0,0x27fe9,0x27fe9,0x0,0x0,0x7f00,0x27fe9,0x27fe9,0x0,0x27fe9,0x27fe9,0x3fc0000,0x0,0x0,0xf0000000,0xf0000000,0xc000000,0xc000000,0x7f00,0x0,0x0,0x9,0x9,0x7fe9,0x0,0xc0,0x7f00,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x1,0x0,0x9,0x9,0x0,0x0,0x1,0x9,0x9,0x0,0x9,0x9,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x9,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public Grammar(InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Grammar(InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new GrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Grammar(Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new GrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Grammar(GrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(GrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private List<int[]> jj_expentries = new ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[68];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 59; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 68; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
