/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\SOFIA.jj */
/*@egen*//**
* JJTree file
*/

options {
  JDK_VERSION = "1.5";
  JAVA_UNICODE_ESCAPE=true;
  UNICODE_INPUT=true;
  STATIC=false;
}
 
PARSER_BEGIN(Grammar) 
package service.asParse;

import java.io.*;
import java.util.*;

public class Grammar/*@bgen(jjtree)*/implements GrammarTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTGrammarState jjtree = new JJTGrammarState();

/*@egen*/
 
  	static String specName;                     //\u93c2\u56e6\u6b22\u6fb6\u7470\u6095
  	static String subSpecName;                  //\u93c2\u56e6\u6b22\u935a\ufffd
  	static String userName;

  	static SpecSysTab specST;                     
  	static SortSysTab sortST;    //\u701b\u6a3a\u7d8b\u9353\u5cf4ort
  	static AttrUnit attrOp;
  	static OperUnit operOp;
  	static AxiomSet axSet;
  	static AxiomUnit axUnit;
  	
  	static VarSysTab varST;
  	static EquationSysTab globalEST;
  	static CondEquation condEST;
  	static LetEquation letEST;
  	static ConditionSysTab conST;
  	static String isGEorLE="GE";
  	
  	static SortSysTab tpSortST;
  	
  	static String CurrSN;
  	static String currOper;

  	static String termString;
  	
  	static ArrayList<String> paraTypeList;
  		
  	static Stack<String> stSort;        //\u701b\u6a3f\u4e32term\u6d93\ue160\u88ab\u701b\u612c\u6095\u93cd\ufffd
  	static Stack<String> stOper;        //\u701b\u6a3f\u4e32term\u6d93\ue15f\u6437\u6d63\u6ec3\u6095\u93cd\ufffd
  	static boolean isLB=false;          //\u93cd\u56e7\u7e54\u8930\u64b3\u58a0\u741b\u3128\u63ea\u5bee\u5fd4\u69f8\u935a\ufe40\u6e6a\u6d93\ue15f\u5aed\u9359\u8702\u8151
  	
  	static TypeException eTE;
  	static String returnMessege;
}
PARSER_END(Grammar)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : 
{
    <POSITIVEINT_TKN:["0"-"9"](["0"-"9"])* >

  | <REAL_TKN: ("-")?["1"-"9"](["0"-"9"])*"."["0"-"9"](["0"-"9"])*>

}

TOKEN :
{
  <SPEC_TKN: "Spec"|"spec">
| <SIG_TKN: "Signature"|"signature">
| <DEF_TKN: "Definition"|"definition">
| <AXIOM_TKN: "Axiom"|"axiom">
| <OBSERVABLE_TKN: "IsObservedBy"|"isobservedby">
| <UNOBSERVABLE_TKN: "Unobservable"|"unobservable">
| <EXTENDS_TKN: "extends">
| <USES_TKN: "uses">
| <CONST_TKN: "Const"|"const">
| <VAR_TKN: "Var"|"var"|"Attr"|"attr">
| <OPERATORS_TKN: "Operation"|"operation">
| <END_TKN: "End"|"end"> 
| <VOID_TKN: "Void"|"void">
| <FORALL_TKN: "For all"|"for all"|"forall">
| <THAT_TKN: "that"|"That">
| <IF_TKN: "If"|"if" >
| <LET_TKN: "Let"|"let">
| <IN_TKN: "in"|"In">

| <LEFTBRACE_TKN: "{">
| <RIGHTBRACE_TKN: "}">
| <SEMICOLON_TKN: ";">
| <COMMA_TKN: ",">
| <SELECTOR_TKN: ":">
| <LEFTBRACKET_TKN: "[">
| <RIGHTBRACKET_TKN: "]">
| <BETWEEN_TKN: "..">
| <LEFTPAREN_TKN: "(">
| <RIGHTPAREN_TKN: ")">

| <NULL_TKN: "Null"|"null" >
| <TRUE_TKN: "True"|"true" >
| <FALSE_TKN: "False"|"false">

| <BOOLEAN_TKN: "Boolean"|"Bool"|"boolean"|"bool">
| <INTEGER_TKN: "Integer"|"integer"|"int"|"Int">
| <LONG_TKN: "Long"|"long">
| <STRING_TKN: "String"|"string">
| <DATETIME_TKN: "Datetime"|"datetime">
| <DOUBLE_TKN: "Double"|"double">
| <FLOAT_TKN: "Float"|"float" >

| <OR_TKN: "or">
| <AND_TKN: "and">
| <NOT_TKN: "not"|"~">
| <ASSIGN_TKN: "=">
| <EQUAL_TKN: "==">
| <NOTEQUAL_TKN: "<>">
| <MORETHAN_TKN: ">">
| <LESSTHAN_TKN: "<">
| <MORETHANEQU_TKN: ">=">
| <LESSTHANEQU_TKN: "<=">
| <OBJECTEQUAL_TKN: "is">

| <DOT_TKN: ".">
| <SHARP_TKN: "#">
| <ADD_TKN: "+">
| <MINUS_TKN: "-">
| <TIMES_TKN: "*">
| <DIVIDE_TKN: "/">
//| <INT_TKN: ("-")?["0"-"9"](["0"-"9"])*> 
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|  < #LETTER: ["_","a"-"z","A"-"Z"] >
|  < #DIGIT: ["0"-"9"] >
}

TOKEN : 
{
 <CSTRING_TKN: "\""( ~["\""])* "\"" >
// <CSTRING_TKN:(\u4e00-\u9fa5)*  >  
}

//<Specification> ::= <Unit> *
//<Unit> ::= <Spec Unit> | <Signature Unit> | <Axiom Unit> | <Definition Unit>
//SpecUnit\u6d93\ue15d\u7b09\u701b\u6a3b\u7621\u6d93\ufffd\u91dc\u7459\u52ed\u5bb3\u9357\u66de\u5393\u934f\u8702\u7d8b\u9350\u546d\ue190
void specification(String specID,String subSpecID,String userID):{/*@bgen(jjtree) specification */
  SimpleNode jjtn000 = new SimpleNode(JJTSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) specification */
          try {
/*@egen*/
	  <LEFTBRACE_TKN>
	  {	  	
	  	System.out.println("160");
	  	specName=specID;                          
	  	subSpecName=subSpecID;
	  	userName=userID;
	  	System.out.println("164");
	  	specST=new SpecSysTab(specID,subSpecID,userID); //\u752f\ufe40\u5f2c\u93c1\u7248\u702f\u95ab\u71ecpecSysTab
	  	specST.clear();                          //\u5a13\u5474\u6ace\u93c1\u7248\u5d41\u6434\u64b2\u8151\u935c\u5bbbpecID\u9286\u4e7bubSpecID\u9429\u7a3f\u53e7\u9428\u52eb\u5534\u7039\ufffd
	  	specST.getExistSubSpec();                //\u7487\u8bf2\u5f47\u93c1\u7248\u5d41\u6434\u64b2\u8151specID\u6d93\ue15e\u53fe\u6d60\u675dubSpec\u9428\u52eb\u5534\u7039\u7678\u7d1d\u9352\u6fc6\ue78a\u9356\u682b\u88ab\u701b\u612c\u6095\u93c1\u626e\u7c8d\u935c\u5c7e\u6437\u6d63\u6ec3\u6095\u93c1\u626e\u7c8d
	  }
	  (SpecUnit()|SigUnit()|AxiomUnit()|DefUnit())*  
	  <RIGHTBRACE_TKN>/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
	  
}

//<Spec unit> ::= 
//  Spec<Sort Name> [<Observability>];
//  [extends <Sort Names>] [uses <Sort Names>]
//  <Signature>; [<Axioms>] 
//  End
//\u59e3\u5fda\u0412\u93cb\u612a\u7af4\u6d93\u733bort\u9357\u66de\u5393\u704f\u535e\u76a2\u7459\uff46\u703d\u7f01\u64b4\u7049\u701b\u6a3a\u53c6\u93c1\u7248\u5d41\u6434\u64c4\u7d1d\u9a9e\u8dfa\u76a2sortName\u935c\u5bb1perName\u701b\u6a3a\u57ccspecUnit
void SpecUnit():{/*@bgen(jjtree) SpecUnit */
                 SimpleNode jjtn000 = new SimpleNode(JJTSPECUNIT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) SpecUnit */
        try {
/*@egen*/
	<SPEC_TKN> t=Identifier()
	{
		System.out.println("begin to parse Spec Unit:" +t.image);
		if(!specST.addUniqSN(t.image))   //\u9352\u3086\u67c7sortID\u935e\ue219\u7af4\u93ac\u044d\u7d1d\u947b\u30e9\u5678\u6fb6\u5d86\u59e4\u95bf\u6b19\u7d1d\u935a\ufe40\u57af\u704f\u55d7\u53fe\u935a\u5d85\u74e7\u701b\u6a3a\u53c6specUnit\u6d93\u74bcortName\u93c1\u626e\u7c8d
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been defined as an operation or a sort name.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
			
		}
		CurrSN=t.image; 
		sortST=new SortSysTab();                //\u93c2\u677f\u7f13\u6d93\ufffd\u91dcsortST\u9357\u66de\u5393
		sortST.setSortName(t.image);		
	}
	(Observability())? <SEMICOLON_TKN>
	(ExtendsSorts() <SEMICOLON_TKN>)?
	(UsesSorts() <SEMICOLON_TKN>)?
	Signature()  
	(Axioms())? 
	<END_TKN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		sortST.writeSortToDB(specName,subSpecName,userName);  //\u704f\u55da\ue1dasort\u701b\u6a3a\u53c6\u93c1\u7248\u5d41\u6434\ufffd
//		System.out.println("Successfully parse the Spec Unit: " + CurrSN);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SigUnit():{/*@bgen(jjtree) SigUnit */
                SimpleNode jjtn000 = new SimpleNode(JJTSIGUNIT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}    //\u6fb6\u52ed\u608a\u935c\u5bbbpec\u9357\u66de\u5393\u9429\u7a3f\u6093
{/*@bgen(jjtree) SigUnit */
        try {
/*@egen*/
	<SIG_TKN> t = Identifier()
	{
		System.out.println("begin to parse Sig Unit:" +t.image);
		if(!specST.addUniqSN(t.image))
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been defined as an operation or a sort name.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
			
		}
		CurrSN=t.image;
		sortST=new SortSysTab();
		sortST.setSortName(t.image);		
	}
	(Observability())? <SEMICOLON_TKN>
	(ExtendsSorts() <SEMICOLON_TKN>)?
	(UsesSorts() <SEMICOLON_TKN>)?
	Signature()
	<END_TKN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		sortST.writeSortToDB(specName,subSpecName,userName);
		System.out.println("Successfully parse the Signature Unit: " + CurrSN);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

//<Axiom Unit> ::=
//  Axiom <Sort Name>;
//    <Axiom List>
//  End
void AxiomUnit():{/*@bgen(jjtree) AxiomUnit */
                  SimpleNode jjtn000 = new SimpleNode(JJTAXIOMUNIT);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) AxiomUnit */
        try {
/*@egen*/
	<AXIOM_TKN> t = Identifier()
	{
		System.out.println("Begin to parse Axiom Unit: "+ t.image);
		if(specST.isUniqSortName(t.image))  		//\u9352\u3085\u757e\u93c4\ue21a\u60c1\u7039\u6c2b\u7b9f\u6769\u56ea\ue1da\u7eeb\u8bf2\u74d9\u935a\ufffd\u947b\u30e6\u6e6d\u7039\u6c2b\u7b9f\u9352\u6b10\u59e4\u95bf\ufffd
		{
			eTE = new TypeException(TypeError.SORT_NOT_DEFINED, "Its signature part has not been defined.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;	
		}
		else
		{
			sortST=new SortSysTab();                    //\u93c2\u677f\u7f13\u6d93\ufffd\u91dcsortST\u9422\u3124\u7c2c\u8930\u64b3\u58a0\u934f\ue102\u608a\u7035\u7470\u7c32\u9428\u52ed\u88ab\u701b\u612a\u4fca\u93ad\ufffd
			sortST.setSortName(t.image);	
			sortST.readSigFromDB(specName,subSpecName,userName);  //\u6d60\u5ea2\u669f\u93b9\ue1bc\u7c31\u6d93\ue161\ue1f0\u9359\u6827\u7d8b\u9353\u5d87\u88ab\u701b\u612e\u6b91\u9369\u9e3f\u769f
		}
	}
	<SEMICOLON_TKN>
	AxiomList()
	<END_TKN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		axSet.writeAxiomToDB(specName,subSpecName,sortST.getSortName(),userName);  //\u704f\u55d7\u53d5\u941e\u55d7\u5553\u934f\u30e6\u669f\u93b9\ue1bc\u7c31
		System.out.println("Successfully parse the Axiom Unit: " + CurrSN);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Definition unit> ::= 
//  Definition [uses <Sort Names>]
//  <Signature>; [<Axioms>] 
//  End
//\u7eeb\u8bf2\u74d9\u935a\u5d84\u8d1fDefiniton\u951b\u5c7d\u53fe\u6d60\u6826\u7b0csort\u9357\u66de\u5393\u9429\u7a3f\u6093\u951b\u5c83\ue1da\u95ae\u3125\u578e\u7487\ue15d\u7b9f\u951b\ufffd
void DefUnit():{/*@bgen(jjtree) DefUnit */
  SimpleNode jjtn000 = new SimpleNode(JJTDEFUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefUnit */
        try {
/*@egen*/
	<DEF_TKN> 
	{
		System.out.println("Begin to parse Defintion Unit!");
		//\u6fb6\u52ed\u608adef\u9357\u66de\u5393
		sortST=new SortSysTab();
		sortST.setSortName("Definition");
	}
	(UsesSorts() <SEMICOLON_TKN>)?  
	Signature()
	(Axioms())? 
	<END_TKN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		sortST.writeSortToDB(specName,subSpecName,userName);
		System.out.println("Successfully parse the Defintion Unit! ");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Observability> ::= is unobservable | is observable by <Op Id>
//\u951b\ufffd
void Observability():{/*@bgen(jjtree) Observability */
                      SimpleNode jjtn000 = new SimpleNode(JJTOBSERVABILITY);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Observability */
        try {
/*@egen*/
	<OBSERVABLE_TKN> t = Identifier()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		sortST.setObOpName(t.image);
	}
	| <UNOBSERVABLE_TKN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExtendsSorts():{/*@bgen(jjtree) ExtendsSorts */
  SimpleNode jjtn000 = new SimpleNode(JJTEXTENDSSORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExtendsSorts */
        try {
/*@egen*/
	<EXTENDS_TKN> ExtendsSortList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExtendsSortList():{/*@bgen(jjtree) ExtendsSortList */
                        SimpleNode jjtn000 = new SimpleNode(JJTEXTENDSSORTLIST);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ExtendsSortList */
        try {
/*@egen*/	
	t = Identifier()
	{
		//\u95c4\u3084\u7c21\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u5bb8\u832c\u7ca1\u6fb9\u7248\u69d1\u6769\u56e8\u69f8\u935a\ufe42\u6e36\u7455\u4f78\u53fe\u6d60\u6827\u57bd\u93c2\ue168\u7d35\u951b\u581f\u762e\u6fe1\u509b\u69f8\u935a\ufe40\u51e1\u7f01\u5fd3\u757e\u6d94\u590e\u7e43\u951b\u71b8\u57a8\u9470\u546e\u6e36\u935a\u5ea1\u57bd\u93c2\ue168\u7d1a
		if(!sortST.addUniqExSortToList(t.image))
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been acted as super one in the sort.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
		}		
	}
	(<COMMA_TKN> ExtendsSortList())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void UsesSorts():{/*@bgen(jjtree) UsesSorts */
  SimpleNode jjtn000 = new SimpleNode(JJTUSESSORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UsesSorts */
        try {
/*@egen*/
	<USES_TKN> UsesSortList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UsesSortList():{/*@bgen(jjtree) UsesSortList */
                     SimpleNode jjtn000 = new SimpleNode(JJTUSESSORTLIST);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) UsesSortList */
        try {
/*@egen*/
	(t = Identifier()| t = BasicType())
	{
		//\u95c4\u3084\u7c21\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u5bb8\u832c\u7ca1\u6fb9\u7248\u69d1\u6769\u56e8\u69f8\u935a\ufe42\u6e36\u7455\u4f78\u53fe\u6d60\u6827\u57bd\u93c2\ue168\u7d35
		if(!sortST.addUniqUsSortToList(t.image))
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Sort Name has been imported in the sort.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			System.out.println(sortST.getSortName());
			throw eTE;
			
		}		
	}
	
	(<COMMA_TKN> UsesSortList())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

//<Signature> ::= {[<Constant>]|[<Attribute>]|[<Operator>]}*
void Signature():{/*@bgen(jjtree) Signature */
  SimpleNode jjtn000 = new SimpleNode(JJTSIGNATURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Signature */
        try {
/*@egen*/
	//\u704f\u5500xtends\u935c\u5bc0ses\u9428\u52eb\u7180\u748b\u51a8\u5bd8\u935a\ue0a5\u7e58\u93c8\ue102\u88ab\u701b\u6136\u7d19\u6d93\u5d89\u6e36\u7455\u4f8a\u7d1a
	(Constant()|Attribute()|Operation())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Constant():{/*@bgen(jjtree) Constant */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Constant */
        try {
/*@egen*/
	<CONST_TKN> <SELECTOR_TKN> ConstList() <SEMICOLON_TKN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConstList():{/*@bgen(jjtree) ConstList */
                  SimpleNode jjtn000 = new SimpleNode(JJTCONSTLIST);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ConstList */
        try {
/*@egen*/
	t=Identifier()
	{
		if(specST.isUniqSortName(t.image))   //\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u935c\u5c7d\u51e1\u7f01\u5fd3\u757e\u6d94\u590c\u6b91sort\u935a\u5d89\u5678\u6fb6\ufffd
		{
			if(sortST.checkOpName(t.image))   //\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u935c\u5c7d\u7d8b\u9353\u5d87\u88ab\u701b\u612a\u8151\u9428\u52eb\u53fe\u6d60\u6758per\u935a\u5d89\u5678\u6fb6\ufffd
			{
				sortST.addConstOpName(t.image);
				specST.addOperName(t.image);
			}
			else 
			{
				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The ConstName has been used as operator name.", t);
				main.messegeString=eTE.returnMessage();
				System.out.println(eTE.prettyMessage());
				throw eTE;	
			}
		}
		else
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The ConstName has been used as sort name.", t);
			main.messegeString=eTE.returnMessage();			
			System.out.println(eTE.prettyMessage());
			throw eTE;	
		}
	}
	(<COMMA_TKN> ConstList())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Attribute> ::= Attr <AttrList>;
void Attribute():{/*@bgen(jjtree) Attribute */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Attribute */
        try {
/*@egen*/
	<VAR_TKN> AttrList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<AttrList> ::= <AttributeType> [; <AttrList>]
void AttrList():{/*@bgen(jjtree) AttrList */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AttrList */
        try {
/*@egen*/
	(AttributeType() <SEMICOLON_TKN>)+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<AttributeType> ::= <Attr IDs> : <Sort Name>  
// {\u7035\u89c4\u7621\u6d93\u72ddttrID\u93c2\u677f\u7f13\u6d93\ufffd\u91dcAttrUnit\u951b\u5c7d\u57b5\u6fee\u5b2a\u5bf2ID,Type\u935a\u5eaf\u7d19\u95c7\ufffd\u57bd\u93c2\ue15e\u608e\u5a09\u66df\ufffd\u951b\u590a\u59de\u934f\u30e5\u7d8b\u9353\u5d87\u88ab\u701b\u6046ttrOpList\u93c1\u626e\u7c8d}
void AttributeType():{/*@bgen(jjtree) AttributeType */
                      SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTETYPE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) AttributeType */
        try {
/*@egen*/
	AttrOpIDs()<SELECTOR_TKN>
	(t = BasicType()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {sortST.setAttrOpType(t.image);}   //\u9359\ue219\u4e92\u93c4\ue21a\u7180\u93c8\ue101\u669f\u93b9\ue1be\u88ab\u9368\ufffd
	| t = Identifier()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{
		if(sortST.checkOpType(t.image))        //\u59ab\ufffd\u7161\u7eeb\u8bf2\u7037\u935a\u581f\u7876\u93ac\u044d\u7d19\u6d93\u7c10oid\u93b4\u6827\u51e1\u7f01\u5fd5\u6575\u93c4\u5ea4\u7e43\u9428\u52ed\u88ab\u701b\u6136\u7d1a
		{
			sortST.setAttrOpType(t.image);         //\u7481\u5267\u7586OpId\u9428\u52ed\u88ab\u9368\ufffd
		}
		else
		{
			eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The Attribute Type Sort has not been declared.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
		}   	}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Attr IDs> ::= <Attr ID> [, <Attr IDs>]
//<Attr ID> ::= <Identifier> [ <Index> ]
void AttrOpIDs():{/*@bgen(jjtree) AttrOpIDs */
                  SimpleNode jjtn000 = new SimpleNode(JJTATTROPIDS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;String index = "";}
{/*@bgen(jjtree) AttrOpIDs */
        try {
/*@egen*/
	t = Identifier()
	{
		attrOp=new AttrUnit();                 //\u93c2\u677f\u7f13\u6d93\ufffd\u91dcAttrUnit\u7035\u7845\u8584
		if(specST.isUniqSortName(t.image))     //\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u935c\u5c7d\u51e1\u93c8\u590c\u88ab\u701b\u612c\u6095\u9350\u832c\u734a
		{
			if(sortST.checkOpName(t.image))    //\u59ab\ufffd\u7161\u93c4\ue21a\u60c1\u935c\u5c7d\u7d8b\u9353\u5d87\u88ab\u701b\u612a\u8151\u9428\u52eb\u53fe\u6d60\u6828\u6437\u6d63\u6ec3\u6095\u9350\u832c\u734a\u951b\u5c7c\u7b09\u9350\u832c\u734a\u9352\u6b0f\u76a2\u934f\u79b7dd\u9352\u677f\u7d8b\u9353\u5cf4ort\u9428\u52ec\u6437\u6d63\u6e19p\u93c1\u626e\u7c8d
			{
				specST.addOperName(t.image);   //\u7eeb\u8bf2\u74d9\u935a\u5d85\u608e\u5a09\u66de\u57af\u704f\u55d7\u76a2\u934f\u79b7dd\u9352\u768apecST\u9428\u523cper\u93c1\u626e\u7c8d
				attrOp.setAttrName(t.image);   //\u7481\u5267\u7586\u8930\u64b3\u58a0attrOp\u9428\u5235ame
			}
			else
			{
				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The AttrOpName has been used as operator name.", t);
				main.messegeString=eTE.returnMessage();
				System.out.println(eTE.prettyMessage());
				throw eTE;	
			}
		}
		else
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The AttrOpName has been used as sort name.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;	
		}
	}
	(index=Index(){attrOp.setIndexString(index);})?
	{sortST.addAttrOpUnit(attrOp);}
	(<COMMA_TKN> AttrOpIDs())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Index> ::= "[" <Index set> "]" 
String Index():{/*@bgen(jjtree) Index */
                SimpleNode jjtn000 = new SimpleNode(JJTINDEX);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/String index = "";}
{/*@bgen(jjtree) Index */
        try {
/*@egen*/
	<LEFTBRACKET_TKN> index= IndexSet() <RIGHTBRACKET_TKN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return index;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Index set> ::= (<Single Index>[,<Index set>]|*)
String IndexSet():{/*@bgen(jjtree) IndexSet */
                   SimpleNode jjtn000 = new SimpleNode(JJTINDEXSET);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String sIndex = ""; String index = "";}
{/*@bgen(jjtree) IndexSet */
        try {
/*@egen*/
	sIndex=SingleIndex(){index=index+sIndex;}
	(t=<COMMA_TKN>{index=index+t.image;}sIndex=IndexSet(){index=index+sIndex;})?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return index;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Single Index> ::= <Enumerated ID> | <Lower bound> ".." <Upper bound>
//<Lower bound> ::= <Natural number>
//<Upper bound> ::= <Natural number> | "*" 
String SingleIndex():{/*@bgen(jjtree) SingleIndex */
                      SimpleNode jjtn000 = new SimpleNode(JJTSINGLEINDEX);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String sToken = "";}
{/*@bgen(jjtree) SingleIndex */
        try {
/*@egen*/
	(((t = <POSITIVEINT_TKN>{ sToken += t.image;}
	 t = <BETWEEN_TKN> { sToken += t.image;}
	(t = <POSITIVEINT_TKN>{ sToken += t.image;} | t = <TIMES_TKN>){ sToken += t.image;})
	| t = Identifier(){ sToken += t.image;})
	|t = <TIMES_TKN>{ sToken += t.image;})/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/                        //?
	{return sToken;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Operator> ::= Operation <OpList>;
void Operation():{/*@bgen(jjtree) Operation */
  SimpleNode jjtn000 = new SimpleNode(JJTOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Operation */
        try {
/*@egen*/
	<OPERATORS_TKN> OpList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<OpList> ::= <Operation> [; <OpList>]
void OpList():{/*@bgen(jjtree) OpList */
  SimpleNode jjtn000 = new SimpleNode(JJTOPLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OpList */
        try {
/*@egen*/
	(Oper() <SEMICOLON_TKN>)+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Operation> ::= <Operator ID> "(" <Domain Type> ")" ":" <Co-domain Type>
void Oper():{/*@bgen(jjtree) Oper */
             SimpleNode jjtn000 = new SimpleNode(JJTOPER);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Oper */
        try {
/*@egen*/
	t = Identifier()
	{
		operOp=new OperUnit();         //\u93c2\u677f\u7f13\u6d93\ufffd\u91dcOperUnit\u7035\u7845\u8584
		if(specST.isUniqSortName(t.image))     //\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u935c\u5c7d\u51e1\u93c8\u590c\u88ab\u701b\u612c\u6095\u9350\u832c\u734a
		{
			if(sortST.checkOpName(t.image))    //\u59ab\ufffd\u7161\u93c4\ue21a\u60c1\u935c\u5c7d\u7d8b\u9353\u5d87\u88ab\u701b\u612a\u8151\u9428\u52eb\u53fe\u6d60\u6828\u6437\u6d63\u6ec3\u6095\u9350\u832c\u734a\u951b\u5c7c\u7b09\u9350\u832c\u734a\u9428\u52ee\u763d\u704f\u55d7\u53feadd\u9352\u677f\u7d8b\u9353\u5cf4ort\u9428\u52ec\u6437\u6d63\u6e19p\u93c1\u626e\u7c8d
			{
				specST.addOperName(t.image);   //\u7eeb\u8bf2\u74d9\u935a\u5d85\u608e\u5a09\u66de\u57af\u704f\u55d7\u76a2\u934f\u79b7dd\u9352\u768apecST\u9428\u523cper\u93c1\u626e\u7c8d
				operOp.setOperName(t.image);   //\u7481\u5267\u7586\u8930\u64b3\u58a0operOp\u9428\u5235ame
			}
			else
			{
				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The GenOpName has been used as operator name.", t);
				main.messegeString=eTE.returnMessage();
				System.out.println(eTE.prettyMessage());
				throw eTE;	
			}
		}
		else
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The GenOpName has been used as sort name.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;	
		}
		//\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u6d93\u7c05bOp
		
	}
	<LEFTPAREN_TKN> (t = <VOID_TKN>{operOp.addDomainType(t.image);}|DomainType()) <RIGHTPAREN_TKN>
	<SELECTOR_TKN> (t = <VOID_TKN>{operOp.addCoDomainType(t.image);}|CodomainType())/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{sortST.addOperOp(operOp);}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

//<Domain Type> ::= <Type> | voidvoid DomainType():{/*@bgen(jjtree) DomainType */
                   SimpleNode jjtn000 = new SimpleNode(JJTDOMAINTYPE);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) DomainType */
        try {
/*@egen*/	(( t = BasicType()
	{
		operOp.addDomainType(t.image);
	} )
	|( t = Identifier()
	{
		if(sortST.checkOpType(t.image))        //\u59ab\ufffd\u7161\u7eeb\u8bf2\u7037\u935a\u581f\u7876\u93ac\u044d\u7d19\u6d93\u54c4\u7d8b\u9353\u5d87\u88ab\u701b\u612d\u57a8\u5bb8\u832c\u7ca1\u9422\u866b\u69d1\u6769\u56e9\u6b91\u7eeb\u8bf2\u74d9\u951b\ufffd
		{
//			if(!operOp.addDomainType(t.image))  //\u59ab\ufffd\u7161\u935e\ue219\u7af4\u93ac\u0443\u6097\u704f\u55da\ue1da\u7eeb\u8bf2\u7037add\u9352\u677f\u7159\u93c1\u626e\u7c8d//			{//				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Type has been acted as super one in domain.", t);//				System.out.println(eTE.prettyMessage());//				throw eTE;//			}     
            operOp.addDomainType(t.image);
		}
		else
		{
			eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The DomainType has not been declared.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
		}   
	}))
	(<COMMA_TKN> DomainType())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}

//<Co-domain Type> ::= <Type> | voidvoid CodomainType():{/*@bgen(jjtree) CodomainType */
                     SimpleNode jjtn000 = new SimpleNode(JJTCODOMAINTYPE);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) CodomainType */
        try {
/*@egen*/	(( t = BasicType(){operOp.addCoDomainType(t.image);} )
	| t = Identifier()
	{
		if(sortST.checkOpType(t.image))         //\u59ab\ufffd\u7161\u7eeb\u8bf2\u7037\u935a\u581f\u7876\u93ac\u044d\u7d19\u6d93\u54c4\u7d8b\u9353\u5d87\u88ab\u701b\u612d\u57a8\u5bb8\u832c\u7ca1\u9422\u866b\u69d1\u6769\u56e9\u6b91\u7eeb\u8bf2\u74d9\u951b\ufffd
		{
//			if(!operOp.addCoDomainType(t.image))//\u59ab\ufffd\u7161\u935e\ue219\u7af4\u93ac\u0443\u6097\u704f\u55da\ue1da\u7eeb\u8bf2\u7037add\u9352\u677f\u7159\u93c1\u626e\u7c8d//			{//				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The Type has been acted as super one in codomain.", t);//				System.out.println(eTE.prettyMessage());//				throw eTE;//			}   
        operOp.addCoDomainType(t.image);
        
		}
		else
		{
			eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The CoDomainType has not been declared.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
		}   
	} )		(<COMMA_TKN> CodomainType())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}

//<Axioms> ::= Axiom: <Axiom List>
void Axioms():{/*@bgen(jjtree) Axioms */
  SimpleNode jjtn000 = new SimpleNode(JJTAXIOMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Axioms */
  try {
/*@egen*/
  <AXIOM_TKN> 
  AxiomList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//<Axiom List> ::= <Axiom> [<Axiom List>]
void AxiomList():{/*@bgen(jjtree) AxiomList */
  SimpleNode jjtn000 = new SimpleNode(JJTAXIOMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AxiomList */
        try {
/*@egen*/
	{
		axSet=new AxiomSet();
	}
	(Axiom())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{sortST.addAxUnit(axSet);}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Axiom> ::= <Var Declarations> <Equations> End|<Equations> 
void Axiom():{/*@bgen(jjtree) Axiom */
  SimpleNode jjtn000 = new SimpleNode(JJTAXIOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Axiom */
        try {
/*@egen*/
	{axUnit=new AxiomUnit();}
	((VarDeclarations()
	Equations()
	{
		axSet.addAxiomUnit(axUnit);
	} <END_TKN>)
	|(Equations()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		axSet.addAxiomUnit(axUnit);
		System.out.println("595");
	}))/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Var Declarations> ::= For all <Var-Sort Pairs> that  \u934f\u3125\u772c\u9359\u6a40\u567a
void VarDeclarations():{/*@bgen(jjtree) VarDeclarations */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDeclarations */
        try {
/*@egen*/
	<FORALL_TKN> VarSortPairs() <THAT_TKN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Var-Sort Pairs> ::= <Var IDs> : <Sort Name> [, <Var-Sort Pairs>]
void VarSortPairs():{/*@bgen(jjtree) VarSortPairs */
  SimpleNode jjtn000 = new SimpleNode(JJTVARSORTPAIRS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarSortPairs */
        try {
/*@egen*/
	VarIDs() <SELECTOR_TKN> Type()
	(<COMMA_TKN> VarSortPairs())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

//<Var IDs> ::= <Var ID> [, <Var IDs>]
void VarIDs():{/*@bgen(jjtree) VarIDs */
               SimpleNode jjtn000 = new SimpleNode(JJTVARIDS);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) VarIDs */
        try {
/*@egen*/
	t = Identifier()
	{
		varST=new VarSysTab();
		if(specST.isUniqSortName(t.image)&&specST.isUniqOperName(t.image))     //\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u935c\u5c7d\u51e1\u93c8\u590c\u88ab\u701b\u612c\u6095\u93b4\u6828\u6437\u6d63\u6ec3\u6095\u9350\u832c\u734a{\u9369\u70d8\u6e70\u93c1\u7248\u5d41\u7eeb\u8bf2\u7037\u935a\u5d8f\u7d35}
		{
			if(axUnit.addGlobVarName(t.image))    //\u59ab\ufffd\u7161\u93c4\ue21a\u60c1\u935c\u5c7d\u51e1\u7f01\u5fd3\u757e\u6d94\u590e\u7e43\u9428\u52eb\u53cf\u705e\ufffd\u5f49\u95b2\u5fd3\u6095\u9350\u832c\u734a
			{
				{varST.setVarName(t.image);}
			}
			else
			{
				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been used as globalvarname.", t);
				main.messegeString=eTE.returnMessage();
				System.out.println(eTE.prettyMessage());
				throw eTE;	
			}
		}
		else
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been used as sort name or an operator name.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;	
		}
		axUnit.addGlobVarST(varST);
	}
	(<COMMA_TKN> VarIDs())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Type> ::= <Sort Name>
void Type():{/*@bgen(jjtree) Type */
             SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	(t = BasicType()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/{axUnit.setVarType(t.image);}    //\u9359\ue219\u4e92\u93c4\ue21a\u7180\u93c8\ue101\u669f\u93b9\ue1be\u88ab\u9368\ufffd
	| t = Identifier()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if(sortST.checkOpType(t.image))        //\u59ab\ufffd\u7161\u7eeb\u8bf2\u7037\u935a\u581f\u7876\u93ac\u044d\u7d19\u6d93\u7c10oid\u93b4\u6827\u51e1\u7f01\u5fd5\u6575\u93c4\u5ea4\u7e43\u9428\u52ed\u88ab\u701b\u6136\u7d1a
		{
			{axUnit.setVarType(t.image);       //\u7481\u5267\u7586OpId\u9428\u52ed\u88ab\u9368\ufffd
            }
		}
		else
		{
			eTE = new TypeException(TypeError.TYPESORT_NOT_Dclared, "The Var Type Sort has not been declared.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
		}   
	}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Equations> ::= <Equation> [<Equations>]
void Equations():{/*@bgen(jjtree) Equations */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Equations */
        try {
/*@egen*/
	(Equation())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Equation> ::=<Cond-Equation>|<Let-Equation>
void Equation():{/*@bgen(jjtree) Equation */
  SimpleNode jjtn000 = new SimpleNode(JJTEQUATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Equation */
        try {
/*@egen*/
	{globalEST=new EquationSysTab();}
	(CondEquation(){globalEST.addConEqua(condEST);}
	|LetEquation(){globalEST.addLetEqua(letEST);})/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{axUnit.addGlobE(globalEST);}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Cond-Equation> ::=<Condition>[<If-Conditions>];
void CondEquation():{/*@bgen(jjtree) CondEquation */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDEQUATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CondEquation */
        try {
/*@egen*/
	{condEST=new CondEquation();}
	(Condition(){condEST.setCond(conST);}
	(<COMMA_TKN> <IF_TKN> Conditions())? <SEMICOLON_TKN>)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Let-Equation> ::=Let <Var Definitions> in <Cond-Equations> End
void  LetEquation():{/*@bgen(jjtree) LetEquation */
  SimpleNode jjtn000 = new SimpleNode(JJTLETEQUATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LetEquation */
        try {
/*@egen*/
	{letEST=new LetEquation();}
	(<LET_TKN>{isGEorLE="LE";} VarDefinitions() <IN_TKN> CondEquations(){isGEorLE="GE";letEST.addConEqua(condEST);} <END_TKN>)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Cond-Equations> ::=<Cond-Equation> [<Cond-Equations>]
void CondEquations():{/*@bgen(jjtree) CondEquations */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDEQUATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CondEquations */
        try {
/*@egen*/
	(CondEquation())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Condition> ::= <Term> <Relation OP> <Term> | ~<Condition>
void Condition():{/*@bgen(jjtree) Condition */
                  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String returnType = "";String termName="";}
{/*@bgen(jjtree) Condition */
        try {
/*@egen*/
	{conST=new ConditionSysTab();}
	((returnType=Term(){conST.setLeftType(returnType);conST.setLeftTerm(termString);}
	t = RelationOP(){conST.setReOp(t.image);}
	returnType=Term()){conST.setRightType(returnType);conST.setRightTerm(termString);}
	| (t=<NOT_TKN> {conST.setConnector(t.image);} Condition()) )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if(!conST.checkType())            //\u7eeb\u8bf2\u7037\u59ab\ufffd\u7161
		{
			eTE = new TypeException(TypeError.TERMSTYPE_NOT_AGREE,"LeftTermType of "+conST.getLeftTerm()+" does not agree with RightTermType of "+conST.getRightTerm(), t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;
		}
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Token RelationOP() :
{/*@bgen(jjtree) RelationOP */
 SimpleNode jjtn000 = new SimpleNode(JJTRELATIONOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) RelationOP */
   try {
/*@egen*/
   ( t = <ASSIGN_TKN> 
  | t = <NOTEQUAL_TKN> 
  | t = <MORETHAN_TKN> 
  | t = <LESSTHAN_TKN> 
  | t = <MORETHANEQU_TKN> 
  | t = <LESSTHANEQU_TKN> 
  | t = <OBJECTEQUAL_TKN>
  | t = <EQUAL_TKN>)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return t;
  }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/ 
}

//<If-Conditions>::= [, if <Conditions>]
//<Conditions> ::= <UnionCondition> ["," <UnionCondition>]
//<UnionCondition>::=<Condition> ("or"<Condition>)*
void Conditions():{/*@bgen(jjtree) Conditions */
                   SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONS);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Conditions */
        try {
/*@egen*/
	Condition()
	{condEST.addIfCond(conST);}
	//	(t=<AND_TKN> | t=<OR_TKN>) Conditions()
	(t=<COMMA_TKN>Conditions()
	{conST.setConnector(t.image);})?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Var Definitions> ::=<Var Assignment> [, <Var Definitions>]
void VarDefinitions():{/*@bgen(jjtree) VarDefinitions */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDefinitions */
        try {
/*@egen*/
	VarAssignment() (<COMMA_TKN> VarDefinitions())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Var Assignment> ::= <Var ID> = <Term>
void VarAssignment():{/*@bgen(jjtree) VarAssignment */
                      SimpleNode jjtn000 = new SimpleNode(JJTVARASSIGNMENT);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String returnType = "";}
{/*@bgen(jjtree) VarAssignment */
        try {
/*@egen*/
	//\u705e\ufffd\u5134\u9359\u6a40\u567a
	t= Identifier()               
	{
		if(specST.isUniqSortName(t.image)&&specST.isUniqOperName(t.image))     //\u9352\u3086\u67c7\u93c4\ue21a\u60c1\u935c\u5c7d\u51e1\u93c8\u590c\u88ab\u701b\u612c\u6095\u93b4\u6828\u6437\u6d63\u6ec3\u6095\u9350\u832c\u734a{\u9369\u70d8\u6e70\u93c1\u7248\u5d41\u7eeb\u8bf2\u7037\u935a\u5d8f\u7d35}
		{
			if(axUnit.checkLocalVarName(t.image)&&letEST.addLocalV(t.image))    //\u59ab\ufffd\u7161\u93c4\ue21a\u60c1\u935c\u5c7d\u51e1\u7f01\u5fd3\u757e\u6d94\u590e\u7e43\u9428\u52eb\u53cf\u705e\ufffd\u5f49\u95b2\u5fd3\u6095\u9350\u832c\u734a
			{
				varST=new VarSysTab();
				varST.setVarName(t.image);
			}
			else
	
			{
				eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been defined.", t);
				main.messegeString=eTE.returnMessage();
				System.out.println(eTE.prettyMessage());
				throw eTE;	
			}
		}
		else
		{
			eTE = new TypeException(TypeError.UNIQUE_DUPLICATION, "The VarName has been used as sort name or an operator name.", t);
			main.messegeString=eTE.returnMessage();
			System.out.println(eTE.prettyMessage());
			throw eTE;	
		}

	}
	<ASSIGN_TKN> returnType=Term()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		varST.setVarTerm(termString);
		varST.setVarType(returnType);
		letEST.addLocalVar(varST);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Term>::=<AddExpression>
String Term():{/*@bgen(jjtree) Term */
               SimpleNode jjtn000 = new SimpleNode(JJTTERM);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/String returntype;}
{/*@bgen(jjtree) Term */
        try {
/*@egen*/
	{
		termString="";
		stSort=new Stack<String>();
		stOper=new Stack<String>();
	}
	returntype=AddExpression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{System.out.println("returntype:"+returntype);System.out.println("term:"+termString);return returntype;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<AddExpression>::=<MulticativeExpression>("+"|"-"|"*"|"/")<MulticativeExpression>*
String AddExpression():{/*@bgen(jjtree) AddExpression */
                        SimpleNode jjtn000 = new SimpleNode(JJTADDEXPRESSION);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;String returntype;}
{/*@bgen(jjtree) AddExpression */
        try {
/*@egen*/
	returntype=MulticativeExpression()(
	(t=<ADD_TKN>|t=<MINUS_TKN>|t=<TIMES_TKN>|t=<DIVIDE_TKN>)
	{termString+=t.image;}
	MulticativeExpression())*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return returntype;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
//<MulticativeExpression>::=
//<UnaryExpression>("."|"#")<UnaryExpression>*
String MulticativeExpression():{/*@bgen(jjtree) MulticativeExpression */
                                SimpleNode jjtn000 = new SimpleNode(JJTMULTICATIVEEXPRESSION);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;String type;String nType="";}
{/*@bgen(jjtree) MulticativeExpression */
        try {
/*@egen*/
	(type=UnaryExpression()
	{
		if(type.equals("unknownOp!"))
		{
			type=sortST.checkOperType(currOper,specName,userName);
			if(type.equals("ConstOp"))stOper.pop();
		}
	})
	((t=<DOT_TKN>
	{
		if(type.equals("error!"))
		{
			System.out.println("varType is wrong!");
		}	
	}
	|t=<SHARP_TKN>)
	{termString+=t.image;}
	nType=UnaryExpression()
	{
		if((sortST.isSort(type)))                 //type\u7eeb\u8bf2\u7037\u6d93\u54c4\u7d8b\u9353\u5d87\u88ab\u701b\ufffd
		{
			type="unknownOp!";                     //\u7481\u5267\u7586type\u7eeb\u8bf2\u7037\u6d93\u7c0enknownOp!
			if(nType.equals("unknownOp!"))        //nType\u6d93\u7c0enknownOp!
			{
				type=sortST.checkOperType(currOper,specName,userName); //\u9352\u3086\u67c7type\u7eeb\u8bf2\u7037   \u9286\u612c\u57bd\u93c2\ue15e\u5f2c\u93c1\u626e\u88ab\u9368\u5b28\ufffd
				stOper.pop();
				if(isLB)					type=stSort.pop();				else 
				    stSort.pop();
				stSort.push(type);			}
		}
		else if(!specST.isUniqSortName(type))       //type\u7eeb\u8bf2\u7037\u6d93\u6d2a\u6f6a\u8930\u64b3\u58a0\u7eeb\u8bf2\u74d9  \u9286\u612c\u57bd\u93c2\ue15e\u5f2c\u93c1\u626e\u88ab\u9368\u5b28\ufffd
		{
			tpSortST=new SortSysTab();
			tpSortST.setSortName(type);
			tpSortST.readSigFromDB(specName,userName);
			type="unknownOp!";
			
			if(nType.equals("unknownOp!"))
			{
				type=tpSortST.checkOperType(currOper,specName,userName);
				stOper.pop();
				if(isLB)
					type=stSort.pop();
				else
				    stSort.pop();
				stSort.push(type);
			}
	    }
	    else {System.out.println("leftDotType error!");}
	})*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	return type;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
//<UnaryExpression>::="("<Term>")"
//|Identifier["("<Parameters>")"]
//|Identifier["[""]"]
//|<CString>
//|<NULL>
//|<Bool>
//|<POSITIVEINT_TKN>
String UnaryExpression():{/*@bgen(jjtree) UnaryExpression */
                          SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;String type="";}
{/*@bgen(jjtree) UnaryExpression */
        try {
/*@egen*/
	((t=<LEFTPAREN_TKN>)          //\u752f\ufe40\u76ac\u93b7\ue100\u5f7f
	{
		termString+=t.image;
	}type=AddExpression()(t= <RIGHTPAREN_TKN>){termString+=t.image;}
	|t=<LEFTBRACKET_TKN>         //\u752f\ufe3f\u8151\u93b7\ue100\u5f7f
	{
		isLB=true;
		termString+=t.image;
	}type=AddExpression()
	t= <RIGHTBRACKET_TKN>
	{
		//type=stSort.pop();
		termString+=t.image;
		isLB=false;
	}
	|
	((t=BasicType()|t=Identifier()){termString+=t.image;}//\u701b\u6943\ue0c1\u951b\u5c7d\u57bd\u93c2\ue160\u88ab\u9368\ufffd
	{
		//\u9352\u3086\u67c7\u7eeb\u8bf2\u7037\u951b\u5822\u88ab\u701b\u612c\u6095\u9286\u4f79\u6437\u6d63\u6ec3\u6095\u9286\u4f78\u5f49\u95b2\u5fd3\u6095\u951b\ufffd
		if(axUnit.isGlobalVar(t.image))   //\u934f\u3125\u772c\u9359\u6a40\u567a
		{
			type=axUnit.getGlobalVarType(t.image);
		    stSort.push(type);
	    }
		else if(sortST.isSort(t.image))   //\u8930\u64b3\u58a0\u7eeb\u8bf2\u74d9\u935a\ufffd
		{
			type=t.image;
			stSort.push(type);
		}      
		else if(isGEorLE.equals("LE"))    //\u705e\ufffd\u5134\u7edb\u590a\u7d21\u6d93\ue160\u6b91\u705e\ufffd\u5134\u9359\u6a40\u567a
		{
			if(letEST.isLocalVar(t.image)) 
			{
			    type=letEST.getLocalVarType(t.image);
			    stSort.push(type);
			}
			else                       //\u6d93\u70d8\u6e6d\u942d\u30e5\u608e\u5a09\u66df\u6437\u6d63\u6ec3\u6095\u93b4\u682d\u6f6a\u5a09\ufffd
		    {
		    	type="unknownOp!";
		    	System.out.println("jjt952"+t.image);
		    	if(sortST.checkOperType(t.image,specName,userName).equals("ConstOp"))
	    	    {
	    	    	type=sortST.getSortName();
	    	    	stSort.push(t.image);
	    	    }
	    	    else
	    	    {
	    	    	currOper=t.image;
	    	    	stOper.push(t.image);
	    	    } 
		    }
		}
		else   //\u6d93\u70d8\u6e6d\u942d\u30e5\u608e\u5a09\u66df\u6437\u6d63\u6ec3\u6095\u93b4\u682d\u6f6a\u5a09\ufffd
	    {
	    	type="unknownOp!";
	    	if(sortST.checkOperType(t.image,specName,userName).equals("ConstOp"))
	    	{
	    		type=sortST.getSortName();
	    		stSort.push(t.image);
	    	}
	    	else
	    	{
	    		currOper=t.image;
	        	stOper.push(t.image);
	    	}
	        
	    }  
	}
	((
	  t=<LEFTPAREN_TKN>
	  {
	  	termString+=t.image;
	  	paraTypeList=new ArrayList<String>();
	  }
	  Parameter()      //\u9352\u6fc6\ue78a\u9356\u6827\u5f2c\u93c1\u626e\u88ab\u9368\u5b2b\u669f\u7f01\ufffd
	  t=<RIGHTPAREN_TKN>
	  {
	  	type="unknownOp!";
	  	//currSort=stSort.peek();
	  	currOper=stOper.peek();
	  	//operOp=new operName();
	  	//operOp.setOperName(operOp);
	  	
	  	termString+=t.image;
	  })
	  |
	  (t=<LEFTBRACKET_TKN>)
	  {termString+=t.image;}
	  (t=Identifier()|t=<POSITIVEINT_TKN>)?
	  t= <RIGHTBRACKET_TKN>
	  {termString+=t.image;System.out.println("967"+termString);}
	  )?)
	|(t=<CSTRING_TKN>){termString+=t.image;type="String";}
	|(t=<POSITIVEINT_TKN>){termString+=t.image;type="Integer";}
    |(t=<REAL_TKN>){termString+=t.image;type="Real";}
	|(t=<NULL_TKN>){termString+=t.image;type="Null";}
	|BoolTerm(){type="Bool";})/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return type;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Parameters>::=<AddExpression>
void Parameter():{/*@bgen(jjtree) Parameter */
                  SimpleNode jjtn000 = new SimpleNode(JJTPARAMETER);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;String paraType;}  //\u9359\u509b\u669f\u7eeb\u8bf2\u7037\u93c1\u626e\u7c8d
{/*@bgen(jjtree) Parameter */
        try {
/*@egen*/
	
	paraType=MulticativeExpression()
	{
		stSort.pop();
		paraTypeList.add(paraType);
	}
	(t=<COMMA_TKN>
	{termString+=t.image;}
	paraType= MulticativeExpression()
	{paraTypeList.add(paraType);}
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{for(int i=0;i<paraTypeList.size();i++)
	System.out.println("942"+paraTypeList.get(i));}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<Bool Term> ::= True | False 
void BoolTerm():{/*@bgen(jjtree) BoolTerm */
                 SimpleNode jjtn000 = new SimpleNode(JJTBOOLTERM);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) BoolTerm */
        try {
/*@egen*/
	(t=<TRUE_TKN>
	|t=<FALSE_TKN>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{termString+=t.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Token Identifier():{/*@bgen(jjtree) Identifier */
                    SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  t=<IDENTIFIER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return t;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Token BasicType() :{/*@bgen(jjtree) BasicType */
                    SimpleNode jjtn000 = new SimpleNode(JJTBASICTYPE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) BasicType */
  try {
/*@egen*/
  (  t=<BOOLEAN_TKN> 
  | t=<INTEGER_TKN> 
  | t=<LONG_TKN>   
  | t=<STRING_TKN>  
  | t=<DATETIME_TKN>
  | t=<DOUBLE_TKN>  
  | t=<FLOAT_TKN>)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return t;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/  
}